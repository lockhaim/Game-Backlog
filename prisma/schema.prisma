// prisma/schema.prisma
// Learn more: https://pris.ly/d/prisma-schema

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL") // Transaction pooler (runtime)
  directUrl = env("DIRECT_URL") // Direct (migrations/Studio)
}

generator client {
  provider = "prisma-client-js"
}

/**
 * Core user
 */
model User {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  email     String   @unique
  name      String?
  image     String?

  // Explicit relation name for clarity
  backlogEntries BacklogEntry[] @relation("UserBacklogEntries")
  userTags       UserTag[]
}

/**
 * Game data comes from Steam appdetails/appreviews
 */
model Game {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  steamAppId Int     @unique
  title      String
  slug       String  @unique
  summary    String?

  headerImageUrl String? // cover/banner
  heroCapsuleUrl String? // optional larger hero image

  developerName String?
  publisherName String?
  releaseDate   DateTime?

  metacriticScore    Int? // from Steam if present
  steamReviewPercent Int? // 0â€“100
  steamReviewCount   Int? // total review count
  steamReviewLabel   String? // e.g., "Very Positive"

  reviewSnippets ReviewSnippet[]
  screenshots    Screenshot[]
  tags           GameTag[]
  platforms      GamePlatform[]
  backlogEntries BacklogEntry[]
}

/**
 * Screenshot carousel (ordered)
 */
model Screenshot {
  id           String   @id @default(cuid())
  createdAt    DateTime @default(now())
  game         Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)
  gameId       String
  imageUrl     String
  thumbnailUrl String?
  sortIndex    Int      @default(0)

  @@index([gameId, sortIndex])
}

/**
 * Optional: small review snippets (can skip if you only want aggregates)
 */
model ReviewSnippet {
  id           String    @id @default(cuid())
  createdAt    DateTime  @default(now())
  game         Game      @relation(fields: [gameId], references: [id], onDelete: Cascade)
  gameId       String
  language     String? // e.g., "english"
  votedHelpful Int? // helpful votes
  reviewText   String // keep short, or truncate upstream
  timestamp    DateTime?
}

/**
 * Taxonomy: tags/genres, platforms
 */
model Tag {
  id    String    @id @default(cuid())
  name  String    @unique
  games GameTag[]
}

model GameTag {
  id     String @id @default(cuid())
  game   Game   @relation(fields: [gameId], references: [id], onDelete: Cascade)
  gameId String
  tag    Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)
  tagId  String

  @@unique([gameId, tagId])
}

model Platform {
  id    String         @id @default(cuid())
  name  String         @unique
  games GamePlatform[]
}

model GamePlatform {
  id         String   @id @default(cuid())
  game       Game     @relation(fields: [gameId], references: [id], onDelete: Cascade)
  gameId     String
  platform   Platform @relation(fields: [platformId], references: [id], onDelete: Cascade)
  platformId String

  @@unique([gameId, platformId])
}

/**
 * Your personal backlog row per game
 */
model BacklogEntry {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Explicit relation name MUST match User.backlogEntries
  user   User   @relation("UserBacklogEntries", fields: [userId], references: [id], onDelete: Cascade)
  userId String

  game   Game   @relation(fields: [gameId], references: [id], onDelete: Cascade)
  gameId String

  backlogStatus BacklogStatus
  userRating    Int?
  userNotes     String?
  priority      Int? // optional: 1 (high) .. 5 (low), etc.
  category      String? // optional: free-text category; switch to enum/table later if desired
  startedAt     DateTime?
  finishedAt    DateTime?
  hoursPlayed   Int?

  @@unique([userId, gameId]) // one entry per user per game
}

/**
 * Per-user custom tags (for autosuggest or personal labels)
 */
model UserTag {
  id     String @id @default(cuid())
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String
  name   String

  @@unique([userId, name])
}

enum BacklogStatus {
  WISHLIST
  PLAYING
  PAUSED
  DROPPED
  FINISHED
}
